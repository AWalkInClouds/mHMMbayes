% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vit_mHMM.R
\name{vit_mHMM}
\alias{vit_mHMM}
\title{Obtain hidden state sequence for each subject using the viterbi
algorithm}
\usage{
vit_mHMM(object, s_data, burn_in = NULL)
}
\arguments{
\item{object}{An object of class \code{mHMM}, generated by the function
\code{mHMM_mnl}.}

\item{s_data}{A matrix containing the observations to be modelled, with one
row per observation. In the \code{s_data} matrix, the first column
indicates subject id number. Hence, the id number is repeated over rows
equal to the number of observations for that subject. The number of
observations can vary over subjects. The subsequent columns contain the
dependent variable(s). The total number of rows are equal to the sum over
the number of observations of each subject, and the number of columns are
equal to the number of dependent variables (\code{n_dep}) + 1.}

\item{burn_in}{The number of iterations to be discarded from the MCMC
algorithm when inferring the transition probability matrix gamma and the
emission distribution of (each of) the dependent variable(s) for each
subject from \code{s_data}. If omitted, defaults to \code{NULL} and the
burn_in period specified at \code{mHMM_mnl} will be used.}
}
\value{
The function \code{vit_mHMM} returns the matrix \code{state_seq} that
  denotes the most likely state at each point in time. Each column represents
  a subject, and each row represents a point in time. If sequence lenghts
  differ over subjects, states for none existing time points for subjects are
  filled with \code{NA}.
}
\description{
\code{vit_mHMM} obtains the most likely state sequence for each subject from
an object of class \code{mHMM} (generated by the function \code{mHMM_mnl}),
using (an extended version of) the Viterbi algorithm. This is also known as
global decoding.
}
\details{
Note that local decoding is also possible, by inferring the most frequent
state at each point in time for each subject from the sampled state path at
each iteration of the MCMC algorithm \code{return_path} of the function
\code{mHMM_mnl}.
}
\examples{
###### First run the function mHMM_mnl on the nonverbal data
# specifying general model properties:
m <- 2
n_dep <- 4
q_emiss <- c(3, 2, 3, 2)

# specifying starting values
start.TM <- diag(.8, m)
start.TM[lower.tri(start.TM) | upper.tri(start.TM)] <- .2
start.EM <- list(matrix(c(0.9, 0.05, 0.05, 0.05, 0.05, 0.9), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.9, 0.1, 0.9, 0.1), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.05, 0.05, 0.9, 0.9, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.9, 0.1, 0.9, 0.1), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out1 <- mHMM_mnl(s_data = nonverbal, gen = list(m = m, n_dep = n_dep,
                q_emiss = q_emiss), start_val = c(list(start.TM), start.EM),
                mcmc = list(J = 11, burn_in = 5))

###### obtain the most likely state sequence with the Viterbi algorithm
states <- vit_mHMM(s_data = nonverbal, object = out1)


}
\seealso{
\code{\link{mHMM_mnl}} for analyzing multilevel hidden Markov data
  and obtaining the input needed for \code{vit_mHMM}, and
  \code{\link{sim_mHMM}} for simulating multilevel hidden Markov data.
}
