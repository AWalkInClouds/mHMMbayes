% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HMM.R
\name{HMM}
\alias{HMM}
\title{Onelevel (fixed) hidden  Markov model using Bayesian estimation}
\usage{
HMM(one_s_data, gen, start_val, mcmc, return_path = FALSE,
  show_progress = TRUE, gamma_prior = NULL, emiss_prior = NULL)
}
\arguments{
\item{one_s_data}{A matrix containing the observations to be modelled of one
subject or sequence, where the rows represent the observations over time,
and the column(s) contain the dependent variable(s). Note that the
dependent variables have to be numeric, i.e., they cannot be a (set of)
factor variable(s).}

\item{gen}{List containing the following elements denoting the general model
properties:
\itemize{\item{\code{m}: numeric vector with length 1 denoting the number
of hidden states}
\item{\code{n_dep}: numeric vector with length 1 denoting the
number of dependent variables}
\item{\code{q_emiss}: numeric vector with length \code{n_dep} denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.}}}

\item{start_val}{List containing the start values for the transition
probability matrix gamma and the emission distribution(s). The first
element of the list contains a \code{m} by \code{m} matrix with the start
values for gamma. The subsequent elements contain \code{m} by
\code{q_emiss[k]} matrices for the start values for each of the \code{k}
emission distribution(s). Note that \code{start_val} should not contain
nested lists (i.e., lists within lists).}

\item{mcmc}{List of Markov chain Monte Carlo (MCMC) arguments, containing the
following elements:
\itemize{\item{\code{J}: numeric vector with length 1 denoting the number
of iterations of the MCMC algorithm}
\item{\code{burn_in}: numeric vector with length 1 denoting the
burn-in period for the MCMC algorithm.}}}

\item{return_path}{A logical scalar. Should the sampled state sequence
obtained at each iteration and for each subject be returned by the function
(\code{sample_path = TRUE}) or not (\code{sample_path = FALSE}). Note that
the sampled state sequence is quite a large object, hence the default
setting is \code{sample_path = FALSE}. Can be used for local decoding
purposes.}

\item{show_progress}{A logical scaler. Should the function show a text
progress bar in the \code{R} console to represent the progress of the
algorithm (\code{show_progress = TRUE}) or not (\code{show_progress =
FALSE}). Defaults to \code{show_progress = TRUE}.}

\item{gamma_prior}{A \code{m} by \code{m} matrix containing the parameters of
the Dirichlet prior distribution on the transition probability matrix. When
left unspecified, defaults to an uninformative prior (that is, all entries
of the matrix equal 1).}

\item{emiss_prior}{A \code{m} by \code{q_emiss} matrix containing the parameters of
the Dirichlet prior distribution on the categrical emission distribution. When
left unspecified, defaults to an uninformative prior (that is, all entries
of the matrix equal 1).}
}
\value{
\code{HMM} returns an object of class \code{HMM}, which has
  \code{print} and \code{summary} methods to see the results.
  The object contains the following components:
  \describe{
  \item{\code{PD}}{A .. containing ...}
}
}
\description{
\code{HMM} fits a onelevel (i.e., fixed parameter) hidden Markov model (HMM)
to intense longitudinal data with categorical observations using Bayesian
estimation, and creates an object of class HMM.
}
\details{
For a short description of
the package see \link{mHMMbayes}. See \code{vignette("tutorial-mhmm")} for an
introduction to multilevel hidden Markov models and the package, and see
\code{vignette("estimation-mhmm")} for an overview of the used estimation
algorithms.
}
\examples{
### first simulate data
# One subject with each n_t observations:
n <- 1
n_t <- 300

# specifying general model properties:
m <- 2
q_emiss <- 3
n_dep <- 1
gamma <- matrix(c(0.8, 0.2,
                  0.2, 0.8), ncol = m, byrow = TRUE)
emiss_distr <- matrix(c(0.50, 0.45, 0.05,
                        0.05, 0.05, 0.90), nrow = m, ncol = q_emiss, byrow = TRUE)

# simulate data
data1 <- sim_mHMM(n_t = n_t, n = n, m = m, q_emiss = q_emiss,
                  gamma = gamma, emiss_distr = emiss_distr)

### analysis of data
# specifying starting values
st_gamma <- matrix(c(0.7, 0.3,
                     0.3, 0.7), ncol = m, byrow = TRUE)
st_emiss_distr <- matrix(c(0.40, 0.40, 0.20,
                           0.20, 0.20, 0.60), nrow = m, ncol = q_emiss, byrow = TRUE)

# run the model
out_2st_sim <- HMM(one_s_data = matrix(data1$obs[,2], ncol = 1),
                    gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                    start_val = list(st_gamma, st_emiss_distr),
                    mcmc = list(J = 4000, burn_in = 200), show_progress = TRUE)

}
\seealso{

}
