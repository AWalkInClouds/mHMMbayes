% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mHMM.R
\name{mHMM}
\alias{mHMM}
\title{Multilevel hidden markov model using Bayesian estimation}
\usage{
mHMM(s_data, gen, xx = NULL, start_val, mcmc, return_path = FALSE,
  gamma_hyp_prior = NULL, emiss_hyp_prior = NULL,
  gamma_sampler = NULL, emiss_sampler = NULL)
}
\arguments{
\item{s_data}{A matrix containing the observations to be modelled, where the
rows represent the observations over time. In the \code{s_data} matrix, the
first column indicates subject id number. Hence, the id number is repeated
over rows equal to the number of observations for that subject. The
subsequent columns contain the dependent variable(s). The total number of
rows are equal to the sum over the number of observations of each subject,
and the number of columns are equal to the number of dependent variables
(\code{n_dep}) + 1. The number of observations can vary over subjects.}

\item{gen}{List containing the following elements denoting the general model
properties:
\itemize{\item{\code{m}: numeric vector with length 1 denoting the number
of states}
\item{\code{n_dep}: numeric vector with length 1 denoting the
number of dependent variables}
\item{\code{q_emiss}: numeric vector with length \code{n_dep} denoting the
number of observed categories for the categorical emission distribution
for each of the dependent variables.}}}

\item{xx}{An optional list of covariates. The first element
  in the list is used to predict the transition matrix. Subsequent elements
  in the list are used to predict the emission distribution of (each of) the
  dependent variable(s). Each element in the list is a matrix, with the
  number of rows equal to the number of subjects. The first column of each
  matrix represents the intercept, that is, a column only consisting of ones.
  Subsequent columns correspond to covariates used to predict the transition
  matrix / emission distribution. See \emph{details} for more information on
  the use of covariates.

  If \code{xx} is omitted completely, \code{xx} defaults to \code{NULL},
  resembling no covariates. Specific elements in the list can also be left
  empty (i.e., set to \code{NULL}) to signify that either the transition
  probability matrix or a specific emission distribution is not predicted by
  covariates.}

\item{start_val}{List containing the start values for the transition
probability matrix gamma and the emission distribuition(s). The first
element of the list contains a \code{m} by \code{m} matrix with the start
values for gamma. The subsequent elements contain \code{m} by
\code{q_emiss[k]} matrices for the start values for each of the \code{k}
conditional distribution(s): one element containing one matrix for each
emission distribtution of dependent variable \code{k}. Note that
\code{start_val} should not contain nested lists (i.e., lists within
lists).}

\item{mcmc}{List of Markov chain Monte Carlo (MCMC) algorithm arguments,
containing the following elements:
\itemize{\item{\code{J}: numeric vector with length 1 denoting the number of iterations of the
MCMC algorithm}
\item{\code{burn_in}: numeric vector with length 1 denoting the
burn-in period for the MCMC algorithm.}}}

\item{return_path}{A logical scalar. Should the sampled state sequence
obtained at each iteration and for each subject be returned by the function
(\code{sample_path = TRUE}) or not (\code{sample_path = FALSE}). This is
quite a large object! Can be used for local decoding purposes. Default
setting is \code{sample_path = FALSE}.}

\item{gamma_hyp_prior}{An optional list containing \code{gamma_mu0}, \code{gamma_K0}, \code{gamma_nu} and \code{gamma_V}, see details below}

\item{emiss_hyp_prior}{An optional list containing \code{emiss_mu0}, \code{emiss_K0}, \code{emiss_nu} and \code{emiss_V}, see details below}

\item{gamma_sampler}{An optional list containing start values for mle estimates of pooled
data for gamma: \code{gamma_int_mle0}, \code{gamma_scalar}, and weight for the overall ll in the
fractional likelihood, \code{gamma_w}.}

\item{emiss_sampler}{An optional list containing start values for mle estimates of pooled
data for emiss, emiss_int_mle0, emiss_scalar and weight for the overall ll in the
fractional likelihood, emiss_w}
}
\value{
\code{mHMM} returns an object (list) of the class \code{mHMM}.
  The list contains the following components:
  \describe{
  \item{\code{PD_subj}}{A list with one matrix per subject containing the xx,
  log likelihood}
  \item{\code{emiss_prob_bar}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{emiss_int_bar}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{emiss_int_subj}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{emiss_naccept}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{gamma_prob_bar}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{gamma_int_bar}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{gamma_int_subj}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{gamma_naccept}}{A matrix containing XX, with
  one row per XX. The columns ... }
  \item{\code{input}}{Overview of used input specifications. Namely, ...}
  \item{\code{sample_path}}{Only returned if .. }
}
}
\description{
\code{mHMM} fits a multilevel hidden Markov model (HMM) using Bayesian
estimation, and creates an object of class mHMM. The function can handle
covariates at level 2 (e.g., the subject level) and varying
observation lengths over subjects. For a short description of the package see
\link{mHMMbayes}. See the vignette \code{tutorial-mHMM} for an introduction
to multilevel hidden Markov models and the package, and see the vignette
\code{estimation-mHMM} for an overview of the used estimation algorithms.
}
\details{
Covariates specified in \code{xx} can either be dichotomous or continuous
variables. Dichotomous variables have to be coded as 0/1 variables.
Categroical or factor variables can as yet not be used as predictor
covariates. The user can however break up the categorical variable in
multiple dummy variables (i.e., dichotomous variables), which can be used
simultaneously in the analysis. Continuous predictors are automatically
centered. That is, the mean value of the covariate is subtracted from all
values of the covariate such that the new mean equals zero. This is done such
that the presented probabilities in the output (i.e., for the population
transiton probability matrix and population emission probabilities)
correspond to the predicted probabilities at the average value of the
covariate(s).
}
\examples{
###### Example on package data
# specifying general model properties:
m <- 2
n_dep <- 4
q_emiss <- c(3, 2, 3, 2)

# specifying starting values
start_TM <- diag(.8, m)
start_TM[lower.tri(start_TM) | upper.tri(start_TM)] <- .2
start_EM <- list(matrix(c(0.05, 0.90, 0.05,
                          0.90, 0.05, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[1]), # vocalizing patient
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[2]), # looking patient
                 matrix(c(0.90, 0.05, 0.05,
                          0.05, 0.90, 0.05), byrow = TRUE,
                        nrow = m, ncol = q_emiss[3]), # vocalizing therapist
                 matrix(c(0.1, 0.9,
                          0.1, 0.9), byrow = TRUE, nrow = m,
                        ncol = q_emiss[4])) # looking therapist

# Run a model without covariate(s):
out_2st <- mHMM(s_data = nonverbal,
                gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                start_val = c(list(start_TM), start_EM),
                mcmc = list(J = 11, burn_in = 5))

out_2st
summary(out_2st)

# plot the posterior densities for the transition and emission probabilities
plot(out_2st, component = "gamma", col =c("darkslategray3", "goldenrod"))

# Run a model including a covariate. Here, the covariate (standardized CDI
# change) predicts the emission distribution for each of the 4 dependent
# variables:
n_subj <- 10
xx <- rep(list(matrix(1, ncol = 1, nrow = n_subj)), (n_dep + 1))
for(i in 2:(n_dep + 1)){
  xx[[i]] <- cbind(xx[[i]], nonverbal_cov$std_CDI_change)
}
out_2st_c <- mHMM(s_data = nonverbal, xx = xx,
                  gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                  start_val = c(list(start_TM), start_EM),
                  mcmc = list(J = 11, burn_in = 5))


###### Example on simulated data
# Simulate data for 10 subjects with each 100 observations:
n_t <- 100
n <- 10
m <- 2
q_emiss <- 3
gamma <- matrix(c(0.8, 0.2,
                  0.3, 0.7), ncol = m, byrow = TRUE)
emiss_distr <- matrix(c(0.5, 0.5, 0.0,
                        0.1, 0.1, 0.8), nrow = m, ncol = q_emiss, byrow = TRUE)
data1 <- sim_mHMM(n_t = n_t, n = n, m = m, q_emiss = q_emiss, gamma = gamma,
                  emiss_distr = emiss_distr, var_gamma = .5, var_emiss = .5)

# Specify remaining required anaylsis input (for now, use simulation input as
# starting values):
n_dep <- 1
q_emiss <- 3

# Run the model on the simulated data:
out_2st_sim <- mHMM(s_data = data1$obs,
                 gen = list(m = m, n_dep = n_dep, q_emiss = q_emiss),
                 start_val = list(gamma, emiss_distr),
                 mcmc = list(J = 11, burn_in = 5))

}
\seealso{
\code{\link{sim_mHMM}} for simulating multilevel hidden Markov data
  and \code{\link{vit_mHMM}} for obtaining the most likely hidden state
  sequence for each subject using the Viterbi algorithm.
}
