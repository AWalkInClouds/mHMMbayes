#' Obtain hidden state sequence for each subject using the viterbi
#' algorithm
#'
#' \code{vit_mHMM} obtains the most likely state sequence for each subject from
#' an object of class \code{mHMM} (generated by the function \code{mHMM_mnl}),
#' using (an extended version of) the Viterbi algorithm. This is also known as
#' global decoding.
#'
#' Note that local decoding is also possible, by inferring the most frequent
#' state at each point in time for each subject from the sampled state path at
#' each iteration of the MCMC algorithm \code{return_path} of the function
#' \code{mHMM_mnl}.
#'
#' @param object An object of class \code{mHMM}, generated by the function
#'   \code{mHMM_mnl}.
#' @inheritParams mHMM_mnl
#' @param burn_in The number of iterations to be discarded from the MCMC
#'   algorithm when inferring the transition probability matrix gamma and the
#'   emission distribution of (each of) the dependent variable(s) for each
#'   subject from \code{out1}. If omitted, defaults to \code{NULL} and the
#'   burn_in period specified at \code{mHMM_mnl} will be used.
#'
#' @return The function \code{vit_mHMM} returns the matrix \code{state_seq} that
#'   denotes the most likely state at each point in time. Each column represents
#'   a subject, and each row represents a point in time. If sequence lenghts
#'   differ over subjects, states for none existing time points for subjects are
#'   filled with \code{NA}.
#'
#' @examples
#' ###### First run the function mHMM_mnl on the nonverbal data
#' # specifying general model properties:
#' m <- 2
#' n_dep <- 4
#' q_emiss <- c(3, 2, 3, 2)
#'
#' # specifying starting values
#' start.TM <- diag(.8, m)
#' start.TM[lower.tri(start.TM) | upper.tri(start.TM)] <- .2
#' start.EM <- list(matrix(c(0.9, 0.05, 0.05, 0.05, 0.05, 0.9), byrow = TRUE,
#'                         nrow = m, ncol = q_emiss[1]), # vocalizing patient
#'                  matrix(c(0.9, 0.1, 0.9, 0.1), byrow = TRUE, nrow = m,
#'                         ncol = q_emiss[2]), # looking patient
#'                  matrix(c(0.05, 0.05, 0.9, 0.9, 0.05, 0.05), byrow = TRUE,
#'                         nrow = m, ncol = q_emiss[3]), # vocalizing therapist
#'                  matrix(c(0.9, 0.1, 0.9, 0.1), byrow = TRUE, nrow = m,
#'                         ncol = q_emiss[4])) # looking therapist
#'
#' # Run a model without covariate(s):
#' out1 <- mHMM_mnl(s_data = nonverbal, gen = list(m = m, n_dep = n_dep,
#'                 q_emiss = q_emiss), start_val = c(list(start.TM), start.EM),
#'                 mcmc = list(J = 11, burn_in = 5))
#'
#' ###### obtain the most likely state sequence with the Viterbi algorithm
#' states <- vit_mHMM(s_data = nonverbal, object = out1)
#'
#'
#' @seealso \code{\link{mHMM_mnl}} for analyzing multilevel hidden Markov data
#'   and obtaining the input needed for \code{vit_mHMM}, and
#'   \code{\link{sim_mHMM}} for simulating multilevel hidden Markov data.
#'
#' @export
#'
#'
vit_mHMM <- function(object, s_data, burn_in = NULL){
  # input should be output object from mHMM_mnl, change output to class 3 type, such that we can check this here
  # number of iterations and burn_in used should be inherited from mHMM_mnl, with the option to change burn_in

  id         <- unique(s_data[,1])
  n_subj     <- length(id)
  n_vary     <- table(s_data[,1])
  max_n      <- max(n_vary)
  state_seq  <- matrix(,ncol = n_subj, nrow = max_n)

  input      <- object$input
  n_dep      <- input$n_dep
  m          <- input$m
  q_emiss    <- input$q_emiss
  emiss      <- rep(list(NULL), n_dep)
  if(is.null(burn_in)){
    burn_in  <- input$burn_in
  }
  J          <- input$J
  for(s in 1:n_subj){
    emiss[[1]] <- matrix(apply(object$PD_subj[[s]][burn_in : J, 1 : (q_emiss[1] * m)], 2, median),
                         byrow = TRUE, ncol = q_emiss[1], nrow = m)
    if(n_dep > 1){
      for(q in 2:n_dep){
        emiss[[q]] <- matrix(apply(object$PD_subj[[s]][burn_in : J, (sum(m * q_emiss[1:(q-1)]) + 1) : sum(m * q_emiss[1:q])], 2, median),
                             byrow = TRUE, ncol = q_emiss[q], nrow = m)
      }
    }
    gamma    <- matrix(apply(object$PD_subj[[s]][burn_in : J, (sum(m * q_emiss) + 1) : (sum(m * q_emiss) + m * m)], 2, median),
                       byrow = TRUE, ncol = m, nrow = m)
    probs    <- cat_Mult_HMM_fw(x = matrix(s_data[s_data[,1] == id[s],][,-1], ncol = n_dep),
                                m = m, emiss = emiss, n_dep = n_dep, gamma = gamma)$forward_p
    state_seq[1:n_vary[s], s] <- apply(probs, 2, which.max)
  }
  colnames(state_seq) <- paste("Subj_", id, sep = "")
  return(state_seq)
}


